        *********** Strategy *************

Стратегия (англ. Strategy) — поведенческий шаблон проектирования,
предназначенный для определения семейства алгоритмов,
инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
Это позволяет выбирать алгоритм путем определения соответствующего класса.
Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов,
которые его используют.

******* Основные характеристики  **********

*** Задача:
По типу клиента (или по типу обрабатываемых данных) выбрать подходящий алгоритм,
который следует применить.
Если используется правило, которое не подвержено изменениям,
нет необходимости обращаться к шаблону «стратегия».

*** Мотивы:
Программа должна обеспечивать различные варианты алгоритма или поведения
Нужно изменять поведение каждого экземпляра класса
Необходимо изменять поведение объектов на стадии выполнения
Введение интерфейса позволяет классам-клиентам ничего не знать о классах,
реализующих этот интерфейс и инкапсулирующих в себе конкретные алгоритмы

*** Способ решения:
Отделение процедуры выбора алгоритма от его реализации.
Это позволяет сделать выбор на основании контекста.

*** Участники
Класс Strategy определяет, как будут использоваться различные алгоритмы.
Конкретные классы ConcreteStrategy реализуют эти различные алгоритмы.
Класс Context использует конкретные классы ConcreteStrategy посредством ссылки
на конкретный тип абстрактного класса Strategy.
Классы Strategy и Context взаимодействуют с целью реализации выбранного алгоритма
(в некоторых случаях классу Strategy требуется посылать запросы классу Context).
Класс Context пересылает классу Strategy запрос, поступивший от его класса-клиента.

*** Следствия
Шаблон Strategy определяет семейство алгоритмов.
Это позволяет отказаться от использования переключателей и/или условных операторов.
Вызов всех алгоритмов должен осуществляться стандартным образом (все они должны иметь
одинаковый интерфейс).

*** Реализация:
Класс, который использует алгоритм (Context),
включает абстрактный класс (Strategy),
обладающий абстрактным методом, определяющим способ вызова алгоритма.
Каждый производный класс реализует один требуемый вариант алгоритма.

*** Замечание:
метод вызова алгоритма не должен быть абстрактным,
если требуется реализовать некоторое поведение, принимаемое по умолчанию.

*** Полезные сведения:
и стратегия, и декоратор может применяться для изменения поведения конкретных классов.
Достоинство стратегии в том, что интерфейс кастомизации не совпадает с публичным интерфейсом
и может быть куда более удобным, а недостаток в том, что для использования стратегии
необходимо изначально проектировать класс с возможностью регистрации стратегий.

*** Использование:
Архитектура Microsoft WDF основана на этом паттерне.
У каждого объекта «драйвер» и «устройство» есть неизменяемая часть,
вшитая в систему, в которой регистрируется изменяемая часть (стратегия),
написанная в конкретной реализации. Изменяемая часть может быть и вовсе пустой,
что даст ничего не делающий драйвер, но при этом способный участвовать в PnP и управлении питанием.

Библиотека ATL содержит в себе набор классов threading model,
которые являются стратегиями (различными реализациями Lock/Unlock,
которые потом используются основными классами системы).
При этом в этих стратегиях используется статический полиморфизм через параметр шаблона,
а не динамический полиморфизм через виртуальные методы.

Паттерн Стратегия основаны на принципе открытости/закрытости,
представляющие ”O” в SOLID принципах, они совершенно разные по намерениям.

Паттерн Стратегия в Java используется для инкапсуляции связанных наборов алгоритмов
для обеспечения гибкости исполнения для клиента.
Клиент может выбрать любой алгоритм во время выполнения без изменения контекста класса,
который использует объект Strategy.
Некоторые популярные примеры паттерна Стратегия – это написание кода,
который использует алгоритмы, например, шифрование, сжатие или сортировки.