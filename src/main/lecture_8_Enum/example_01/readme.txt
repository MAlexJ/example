``````````````````````````````````````````````````````````````````````````````````````````````````````
#1 Перечисление - это класс

Объявляя enum мы неявно создаем класс производный от java.lang.Enum.
Условно конструкция enum Season { ... } эквивалентна class Season extends java.lang.Enum { ... }.
И хотя явным образом наследоваться от java.lang.Enum нам не позволяет компилятор,
все же в том, что enum наследуется, легко убедиться с помощью reflection:
System.out.println(Season.class.getSuperclass());

На консоль будет выведено:
class java.lang.Enum

```````````````````````````````````````````````````````````````````````````````````````````````````````
#2 Элементы перечисления - экземпляры enum-класса, доступные статически

Элементы enum Season (WINTER, SPRING и т.д.) - это статически доступные экземпляры enum-класса Season.
Их статическая доступность позволяет нам выполнять
сравнение с помощью оператора сравнения ссылок ==. Пример:

Season season = Season.SUMMER;
if (season == Season.AUTUMN) season = Season.WINTER;

````````````````````````````````````````````````````````````````````````````````````````````````````````
#3 Название и порядковый номер элемента enum

Как уже было сказано ранее любой enum-класс наследует java.lang.Enum,
который содержит ряд методов полезных для всех перечислений. Пример:

Season season = Season.WINTER;
System.out.println("season.name()=" + season.name()
                                    + " season.toString()=" + season.toString()
                                    + " season.ordinal()=" + season.ordinal());
Будет выведено:

season.name()=WINTER season.toString()=WINTER season.ordinal()=0

Здесь показано использования методов name(), toString() и ordinal().
Семантика методов - очевидна.
Следует обратить внимание, что данные методы enum-класс наследует из класса java.lang.Enum

``````````````````````````````````````````````````````````````````````````````````````````````````````````
#4 Получение елемента enum по строковому представлению его имени

Довольно часто возникает задача получить элемент enum по его строковому представлению.
Для этих целей в каждом enum-классе компилятор автоматически создает специальный статический метод:

public static EnumClass valueOf(String name), который возвращает элемент перечисления EnumClass с названием, равным name.

 Пример использования:

String name = "WINTER";
Season season = Season.valueOf(name);

В результате выполнения кода переменная season будет равна Season.WINTER.
Cледует обратить внимание, что если элемент не будет найден,
то будет выброшен IllegalArgumentException, а в случае, если name равен null - NullPointerException.

Об этом, кстати, часто забывают.
Почему-то многие твердо уверенны, что если функция принимает один аргумент и при некоторых услових
выбрасывает IllegalArgumentException, то при передачи туда null, также будет неприменно
выброшен IllegalArgumentException.
Но это не относится к делу.

```````````````````````````````````````````````````````````````````````````````````````````````````````
#5 Получение всех элементов перечисления

Иногда необходимо получить список всех элементов enum-класса во время выполнения.
Для этих целей в каждом enum-классе компилятор создает метод:

public static EnumClass[] values().

Пример использования:

System.out.println(Arrays.toString(Season.values()));

Получим вывод:

[WINTER, SPRING, SUMMER, AUTUMN]

Обратите внимание, что ни метод valueOf(), ни метод values() не определен в классе java.lang.Enum.
Вместо этого они автоматически добавляются компилятором на этапе компиляции enum-класса.

```````````````````````````````````````````````````````````````````````````````````````````````````````

#6